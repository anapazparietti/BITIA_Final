<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Historia de la M칰sica - Bitia</title>

<link rel="stylesheet" href="nucleo-1/style.css">
<link rel="stylesheet" href="estilos/style-general.css">
<link rel="stylesheet" href="estilos/taskbar.css">
</head>
<body>

<div class="container" id="mainContainer">

    <audio id="musica-nucleo-1" src="/Musicas/frutiger-song-nucleo-1.mp3"></audio>
  
  <div class="container2">
    <img src="Dise침o/Loops/Loop6 (2).png" alt="" style="width: 700px; margin-bottom: -20px;">
  </div>

  <aside class="rightbar" id="rightBar">

    <div><a href="Nucleo1.html"><img src="Dise침o/Frame 4 (1).png" alt=""></a></div>
    <div><a href="#"><img src="Dise침o/Frame 23 (2).png" alt=""></a></div>
    <div><a href="#"><img src="Dise침o/Frame 24 (1).png" alt=""></a></div>
  </aside>
</div>
<!---------- BARRA DE TAREAS ---------->
        <div class="taskbar">
            <img class="taskbar-logo" src="../img/windows-vista-icon-seeklogo.png" alt="">
        </div>
<script>
    // IMPORTAR TECLAS GLOBALES
    const KEYS = window.parent.BITIA_KEYS || { ACCION: '+', ARRIBA: '8', ABAJO: '0', PLAY: '-', SALIR: 'e' };

    // VARIABLE DE MODO
    window.modoSidebar = false; 

    // ELEMENTOS
    const tarjetas = document.querySelectorAll('.calendario-ventana');
    const rightBarImgs = document.querySelectorAll('.rightbar img');
    let rightBarIndex = 0;
    let indiceCarrusel = 0;
    
    // MATH VISUAL ORIGINAL
    const ESPACIADO_X = 140;
    const ESPACIADO_Z = 180;
    const ROT_Y = 0;
    const FRONT_Z = 160;
    const FRONT_ESCALA = 1.06;

    // === ACTUALIZAR CARRUSEL ===
    function actualizarCarrusel() {
        tarjetas.forEach((tarjeta, i) => {
            const offset = i - indiceCarrusel;
            const absOff = Math.abs(offset);

            if (offset === 0) {
                tarjeta.classList.add('front');
                tarjeta.style.transform = `translateX(0px) translateZ(${FRONT_Z}px) rotateY(0deg) scale(${FRONT_ESCALA})`;
                tarjeta.style.opacity = '1';
                tarjeta.style.zIndex = '1000';
            } else {
                tarjeta.classList.remove('front');
                const dir = offset < 0 ? 1 : -1;
                const x = offset * ESPACIADO_X;
                const z = -absOff * ESPACIADO_Z;
                const rotY = dir * ROT_Y;
                tarjeta.style.transform = `translateX(${x}px) translateZ(${z}px) rotateY(${rotY}deg) scale(1)`;
                tarjeta.style.opacity = String(Math.max(0.20, 1 - absOff * 0.25));
                tarjeta.style.zIndex = String(900 - absOff);
            }
        });
    }

    // === ACTUALIZAR SIDEBAR ===
    function updateRightbarFocus() {
        rightBarImgs.forEach((img, i) => {
            if (window.modoSidebar && i === rightBarIndex) {
                img.classList.add('focused');
            } else {
                img.classList.remove('focused');
            }
        });
    }

    // === CONTROL DE MODO ===
    let accionTimeout = null;
    let accionLongPress = false;
    // 游댠 AUMENTADO A 2 SEGUNDOS PARA EVITAR ACCIDENTES 游댠
    const accionHoldThreshold = 2000; 
    
    function toggleMode() {
        window.modoSidebar = !window.modoSidebar;
        updateRightbarFocus();
        
        // Luces Arduino
        try {
            const parentApp = window.parent.app;
            if (parentApp && typeof parentApp.setNucleo === 'function') {
                if (window.modoSidebar) parentApp.setNucleo(0); // Amarillo
                else parentApp.setNucleo(1); // Verde
            }
        } catch (e) {}
    }

    // === TECLADO CON PROTECCI칍N DE REPETICI칍N ===
    window.addEventListener('keydown', (e) => {
        // 游댠 IMPORTANTE: Ignora si la tecla se queda pegada por el sistema
        if (e.repeat) return;

        const key = e.key.toLowerCase();

        // ACCION MANTENIDA
        if (key === KEYS.ACCION) {
            accionLongPress = false;
            accionTimeout = setTimeout(() => {
                accionLongPress = true;
                toggleMode();
            }, accionHoldThreshold); 
        }
    });

    window.addEventListener('keyup', (e) => {
        if (e.key.toLowerCase() === KEYS.ACCION) {
            // Si soltamos antes de tiempo, limpiamos el timer
            if (accionTimeout) {
                clearTimeout(accionTimeout);
                accionTimeout = null;
            }
            
            // Click corto en sidebar
            // 游댠 Solo si NO fue pulsaci칩n larga 游댠
            if (!accionLongPress) {
                if (window.modoSidebar) {
                    const target = rightBarImgs[rightBarIndex];
                    const parentLink = target.closest('a');
                    // Evita recargar si el link apunta a s칤 mismo (# o vacio)
                    if (parentLink && parentLink.getAttribute('href') && parentLink.getAttribute('href') !== '#') {
                        window.location.href = parentLink.getAttribute('href'); 
                    }
                } else {
                    // En modo carrusel, el click corto puede avanzar 1 slide (opcional)
                    // O simplemente no hacer nada para evitar confusiones
                }
            }
            
            // Reseteamos bandera
            accionLongPress = false;
        }
        
        if (e.key.toLowerCase() === KEYS.SALIR) {
            window.location.href = 'index.html';
        }
    });

    // Instrucciones.html: Control de Scroll de Rat칩n/Trackpad (NUEVO C칍DIGO)

    // === ENCODER === (C칩digo existente que se debe mantener)
    window.addEventListener('message', (evento) => {
        if (evento.data && evento.data.tipo === 'ENCODER_BITIA') {
            const delta = (evento.data.dir === "CW") ? 1 : -1;

            if (window.modoSidebar) {
                // Mover Sidebar
                rightBarIndex = (rightBarIndex + delta + rightBarImgs.length) % rightBarImgs.length;
                updateRightbarFocus();
            } else {
                // Mover Carrusel (Solo visual)
                indiceCarrusel += delta; 
                if (indiceCarrusel < 0) indiceCarrusel = 0;
                if (indiceCarrusel > tarjetas.length - 1) indiceCarrusel = tarjetas.length - 1;
                actualizarCarrusel();
            }
        }
    });
    
    // === SCROLL DE RAT칍N/TRACKPAD === (NUEVO C칍DIGO)
    document.addEventListener('wheel', (e) => {
        
        e.preventDefault(); // Evita el scroll nativo de la p치gina

        // Determinamos la direcci칩n: deltaY > 0 es scroll hacia abajo (Avanza, +1), deltaY < 0 es scroll hacia arriba (Retrocede, -1).
        const delta = e.deltaY > 0 ? 1 : (e.deltaY < 0 ? -1 : 0);

        // Si hay movimiento (delta no es 0)
        if (delta !== 0) {
            
            if (window.modoSidebar) {
                // Mover Sidebar, imitando el Encoder
                rightBarIndex = (rightBarIndex + delta + rightBarImgs.length) % rightBarImgs.length;
                updateRightbarFocus();
                
            } else {
                // Mover Carrusel, imitando el Encoder
                indiceCarrusel += delta; 
                
                // Limitamos el 칤ndice
                if (indiceCarrusel < 0) indiceCarrusel = 0;
                if (indiceCarrusel > tarjetas.length - 1) indiceCarrusel = tarjetas.length - 1;
                
                // Actualizamos la vista 3D
                actualizarCarrusel();
            }
        }
    }, { passive: false });
    
    
    // === INICIALIZAR ===
// ... (El resto del script de Instrucciones.html)

    // === INICIALIZAR ===
    actualizarCarrusel();
    updateRightbarFocus();

    // Forzar Estado 1 (Verde) al cargar
    document.addEventListener('DOMContentLoaded', () => {
        setTimeout(() => {
            try {
                const parentApp = window.parent.app;
                if (parentApp && typeof parentApp.setNucleo === 'function') {
                    parentApp.setNucleo(1); 
                }
            } catch (e) {}
        }, 200);
    });

</script>

</body>
</html>